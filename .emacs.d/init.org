#+STARTUP: showeverything

* Introduction

This file describes the configuration of my Emacs environment.

* Reading This Document

This file is a literate programming document written with Org-mode and
Org-babel. You can generate an Emacs Lisp (.el) file for configuring
Emacs, and an HTML (.htm) file you can display in your favorite
browser.

* Generating This Document

Here's a convenience function that generates the files mentioned in
the previous section:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (defun export-init-org ()
    "Generate init.el and init.htm from the current init.org file."
    (interactive)
    (call-interactively #'org-babel-tangle)
    (call-interactively #'org-html-export-as-html))
#+END_SRC

* Contents

** General Folder Structure

 The load path is the list of directories that Emacs searches for
 executing Elisp code (i.e. by using "require").

 I store the Emacs Lisp code that I write inside the user-lisp folder.

 #+BEGIN_SRC emacs-lisp :tangle yes :comments org
   (add-to-list 'load-path "~/.emacs.d/user-lisp")
 #+END_SRC

** Package Management

I use ELPA packages, mainly from the MELPA repository:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'package)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "http://orgmode.org/elpa/")))
  (package-initialize)
#+END_SRC

Bootstrap use-package:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

Add an environment variable required by the PDF Tools package:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setenv "PKG_CONFIG_PATH" "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig:/usr/local/lib/pkgconfig:/opt/X11/lib/pkgconfig")
#+END_SRC

** General Customizations

Start Emacs fully maximized:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

Some general functions that I've written.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'defuns-config)
#+END_SRC

And some general keybinding modifications.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'keybindings)
#+END_SRC

*** Mac

On a Mac, I use the Command key as Meta.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq mac-option-modifier 'none)
  (setq mac-command-modifier 'meta)
  (setq ns-function-modifier 'hyper)
#+END_SRC

GUI apps on macOS do not inherit $PATH from shell. This package solves
that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :config
    (progn
      (setq exec-path-from-shell-arguments '("-l"))
      (setq exec-path-from-shell-variables
            (append exec-path-from-shell-variables '("JAVA_HOME")))
      (exec-path-from-shell-initialize)))
#+END_SRC

*** Appearance and Themes

I use a custom black theme by default, but I open the possibility to
use another for a special purpose (excellent Org-Mode support, a
presentation, etc.)

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'appearance)
#+END_SRC

*** Ediff

I like Ediff's control panel to show in a separate frame, even on
graphical environments.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

*** File Backup Management

Store Emacs backup files in their own directory, so as not to pollute
the current directory.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq auto-save-list-file-name-transforms '((".*", "~/.emacs.d/auto-save-list" t)))
#+END_SRC

*** Ido and Recentf

I use Ido ("Interactive Do") as a simple way to switch between open
buffers.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (ido-mode t)
#+END_SRC

Recentf is a mode for displaying recently open files.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (recentf-mode 1)
#+END_SRC

*** Line Numbers

I use linum mode, but only for programming modes.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

Format linum-mode output by appending a space at the end.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq linum-format "%d ")
#+END_SRC

I also highlight the current line, only for programming modes.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

*** Mode Line

Show in which function or method the point is.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (which-function-mode 1)
#+END_SRC

Show column numbers in the mode line.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (column-number-mode 1)
#+END_SRC

I don't want some minor modes polluting my mode line. I use the
diminish package to avoid that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package diminish
    :ensure t
    :defer t)
#+END_SRC

Show the current time.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package time
    :config
    (progn
      (setf display-time-default-load-average nil
            display-time-use-mail-icon t
            display-time-24hr-format nil)
      (display-time-mode t)))
#+END_SRC

*** Navigation Tree

Show a project navigation tree using Neotree package.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package neotree
    :ensure t
    :defer t
    :config
    (global-set-key [f8] 'neotree-toggle))
#+END_SRC

*** Pairs

To ease working with pairs, I use the smartparens package.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package smartparens
    :ensure t
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package smartparens-config
    :ensure smartparens
    :defer t
    :config
    (progn
      (show-smartparens-global-mode t))
      (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
      (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode))
#+END_SRC

Highlight parentheses pairs.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (show-paren-mode 1)
#+END_SRC

Close pairs automatically.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (electric-pair-mode 1)
#+END_SRC

Rainbow-delimiters is a package which highlights delimiters such as
parentheses, brackets or braces according to their depth

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package rainbow-delimiters
    :ensure t
    :defer t
    :init
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
    :config
    (set-face-foreground 'rainbow-delimiters-depth-1-face "snow4")
    (setf rainbow-delimiters-max-face-count 1)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error)
    (set-face-foreground 'rainbow-delimiters-depth-1-face "snow4"))
#+END_SRC

*** Trailing Whitespace

Remove trailing whitespace before saving a file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Window Management

I use winner-mode to manage my windows with convenient undo/redo functions.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (winner-mode 1)
#+END_SRC

*** Cross References

Use ivy-xref to select cross references:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ivy-xref
    :ensure t
    :after ivy
    :init (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

** Programming Language Customizations

These are my customizations for the programming languages I use most.

I generally dislike tabs in my programs.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** C/C++/Objective-C/Objective-C++

For C languages, I use K&R style, with an indentation of 2 spaces.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cc-mode
    :config
    (add-hook 'c-mode-common-hook (lambda ()
                             (c-set-style "k&r")
                             (setq c-basic-offset 2))))
#+END_SRC

As there's not a specific Emacs mode for this programming language,
for Objective-C++ files, use Objective-C mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'auto-mode-alist '("\\.mm$" . objc-mode))
#+END_SRC

Use LSP with flycheck, company, and cquery as C++ client.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
    (use-package lsp-mode
      :ensure t
      :defer t
      :load-path "~/.emacs.d/vendor/lsp-ui")
#+END_SRC

LSP UI contains higher level UI modules for lsp-mode, like flycheck
support or code lenses.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package lsp-ui
    :ensure t
    :load-path "~/.emacs.d/vendor/lsp-ui"
    :config
    (with-eval-after-load 'lsp-mode
      (add-hook 'lsp-after-open-hook (lambda () (lsp-ui-flycheck-enable t)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package company-lsp
    :ensure t
    :after lsp-mode
    :config
    (add-to-list 'company-backends 'company-lsp))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ccls
    :ensure t
    :init
    (setq ccls-executable (expand-file-name "~/Projects/ccls/release/ccls"))
    (setq ccls-extra-args '("--log-file=/tmp/cq.log")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cquery
    :ensure t
    :defer t
    :load-path "~/.emacs.d/vendor/emacs-cquery"
    :config
    (setq cquery-executable (expand-file-name "~/cquery/bin/cquery"))
    (setq cquery-additional-arguments '("--log-stdin-stdout-to-stderr")))
#+END_SRC

Function to launch cquery whenever there's a compilation database in
the C/C++ project I'm working on.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
    (defun dm/enable-cquery-if-compile-commands-json ()
      "Enables cquery (a C++ LSP server) if the current project has
  a compile_commands.json or .cquery file."
      (interactive)
      (when
          (and (not (and (boundp 'lsp-mode) lsp-mode))
               (or (locate-dominating-file default-directory "compile_commands.json")
                   (locate-dominating-file default-directory ".cquery")))
        (setq eldoc-idle-delay 0.2)
        (lsp-cquery-enable)
        (when (>= emacs-major-version 26)
          (lsp-ui-doc-mode 1))))
#+END_SRC

I want to integrate clang-tidy checks with flycheck:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package flycheck-clang-tidy
    :ensure t
    :defer t
    :init
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook #'flycheck-clang-tidy-setup))
    :config
    (setq flycheck-c/c++-clang-tidy-executable "~/Projects/llvm/release/bin/clang-tidy"))
#+END_SRC

*** Clojure

Cider is the "de facto" package for working on Clojure projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cider
    :ensure t
    :defer t)
#+END_SRC

*** Djinni

Djinni is a IDL by Dropbox that helps generating interface code in C++/Objective-C++/Java.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/Projects/PSPDFKit/core/tools/")
  (require 'djinni-mode)
#+END_SRC

*** Emacs Lisp

Suggest.el is a nice package that helps you discover Elisp functions
that do what you want.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package suggest
    :ensure t
    :defer t)
#+END_SRC

*** Haskell

For Haskell I use haskell-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package haskell-mode
    :ensure t
    :defer t)
#+END_SRC

*** JavaScript

Use js2-mode for JavaScript.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package js2-mode
    :ensure t
    :defer t
    :mode ("\\.js\\'" . js2-mode))
#+END_SRC

*** Kotlin

Use kotlin-mode for Kotlin development.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package kotlin-mode
    :ensure t
    :defer t
    :mode ("\\.kt\\'" . kotlin-mode))
#+END_SRC

*** LaTeX

Use Auctex with tex-site for an excellent LaTeX environment. Also,
enable RefTeX mode whenever a LaTeX document is open.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package tex-site
    :ensure auctex
    :defer t
    :config
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex))
#+END_SRC

*** Markdown

I use markdown-mode to work on Markdown (.md) documents.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package markdown-mode
    :ensure t
    :defer t
    :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode))
#+END_SRC

I want to fontify code blocks in Markdown:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq markdown-fontify-code-blocks-natively t)
#+END_SRC

*** PHP

Emacs does not come with a mode for editing PHP mode. Just use
php-mode form the package repository.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package php-mode
    :ensure t
    :defer t
    :mode ("\\.php\\'" . php-mode))
#+END_SRC

*** Proselint

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
            (id (one-or-more (not (any " "))))
            (message) line-end))
  :modes (gfm-mode
          markdown-mode
          org-mode
          text-mode))

(add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

*** Python

There are several packages for writing Python code. I use python.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package python
    :ensure t
    :defer t
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+END_SRC

Anaconda provides navigation documentation lookup and code completion
for Python:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package lsp-python
    :ensure t
    :after python
    :config
    (add-hook 'python-mode-hook #'lsp-python-enable))
#+END_SRC

Format Python code according to PEP8:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package py-autopep8
    :ensure t
    :after python
    :bind
    (:map python-mode-map
          ("C-c u" . py-autopep8-buffer))
    :config
    (setq py-autopep8-options '("--max-line-length=79")))
#+END_SRC

*** Rust

Use rust-mode for editing Rust code:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package rust-mode
    :ensure t
    :defer t)
#+END_SRC

For code completion and navigation use Racer:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package racer
    :ensure t
    :after rust-mode
    :config
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)
    (add-hook 'racer-mode-hook #'company-mode)
    (require 'rust-mode)
    (define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common)
    (setq company-tooltip-align-annotations t)
    :after rust-mode)
#+END_SRC

*** Shell

For linting Shell scripts, I integrate Shellcheck with Flycheck.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC

*** Swift

I use swift-mode for Swift code.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package swift-mode
    :ensure t
    :defer t
    :mode ("\\.swift\\'" . swift-mode)
    :config
    (setq flycheck-swift-sdk-path "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk")
    (add-to-list 'flycheck-checkers 'swift))
#+END_SRC

*** TableGen

TableGen is an abstract IDL used by LLVM and related projects to
generate code automatically.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/Projects/llvm/utils/emacs")
  (require 'tablegen-mode)
#+END_SRC

** General Productivity Packages

This is the list of the packages I use for productivity when
programming, writing in a natural language, or managing Git, for
example.

*** Autocompletion

Autocompletion is very important for programming languages and natural
languages. I use company for that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package company
    :ensure t
    :defer t
    :diminish company-mode
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-backends (delete 'company-semantic company-backends)))
#+END_SRC

*** CMake

CMake is a meta-build system that is commonly used in C++ projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cmake-mode
    :ensure t
    :defer t)
#+END_SRC

*** Code Formatting

Code formatting tools make smarter decisions than typical Emacs
indenters, specially for complex languages like C++. As yet, I use
clang-format for C++ and related languages.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package clang-format
    :ensure t
    :bind
    (:map c++-mode-map
          ("C-c i" . clang-format-region)
          ("C-c u" . clang-format-buffer)))
#+END_SRC

*** Code Navigation

Sourcetrail is a great indexer to make sense of a big C/C++/Java
project.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package sourcetrail
    :ensure t
    :defer t
    :bind
    ("C-c s" . sourcetrail-send-location))
#+END_SRC

For quick navigation inside a source file, I use ace-jump-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ace-jump-mode
    :ensure t
    :defer t
    :init
    (global-set-key (kbd "C-c SPC") 'ace-jump-mode))
#+END_SRC

Typically, I want to navigate quickly over the instances of a
particular symbol in a source file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package highlight-symbol
    :ensure t
    :config
    (define-key prog-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key prog-mode-map (kbd "M-p") 'highlight-symbol-prev)
    ;; Modes that inherit from c-mode aren't affected by prog-mode-map,
    ;; so we have to set bindings again.
    (define-key c-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key c-mode-map (kbd "M-p") 'highlight-symbol-prev)
    (define-key c++-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key c++-mode-map (kbd "M-p") 'highlight-symbol-prev)
    (define-key java-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key java-mode-map (kbd "M-p") 'highlight-symbol-prev))
#+END_SRC

*** Code Selection

Use expand-region to increase the selected region by semantic units.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package expand-region
    :ensure t
    :defer t
    :init
    (global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

*** Debugging

Debugging is very important when working on a program. I use RealGud,
which is a nice abstraction over several debuggers for programming
languages.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package realgud
    :ensure t
    :defer t)
#+END_SRC

# #+BEGIN_SRC emacs-lisp :tangle yes :comments org
#   (add-to-list 'load-path "~/Projects/realgud-lldb/lldb/")
#   (require 'realgud-lldb)
# #+END_SRC


*** Documentation

For showing inline documentation for Emacs Lisp functions, I use eldoc.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package eldoc
    :ensure t
    :defer t
    :diminish eldoc-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode))
#+END_SRC

In general, I use Dash docsets for any programming language. For now,
dash-at-point only works for C++ files.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package dash-at-point
    :ensure t
    :defer t
    :config
    (add-to-list 'dash-at-point-mode-alist '(c++-mode . "cpp"))
    :bind
    ("C-c h" . dash-at-point))
#+END_SRC

*** Git

For working on Git repositories and associated services (currently
GitHub only) I use several packages.

**** Magit

Magit is the best Git porcelain I've ever used.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package magit
    :ensure t
    :bind
    ("C-x g" . magit-status)
    :config
    (magit-add-section-hook 'magit-status-sections-hook
                            'magit-insert-modules-overview
                            'magit-insert-unpulled-from-upstream)
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+END_SRC

**** MagitHub

MagitHub extends Magit with functions to work on GitHub repositories
(show open issues, PRs, etc.).

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package magithub
    :after magit
    :ensure t
    :config
    (magithub-feature-autoinject t))
#+END_SRC

**** Git TimeMachine

git-timemachine is a package that intuitively shows previous versions
of a particular file from a Git repository.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package git-timemachine
    :ensure t
    :defer t)
#+END_SRC

**** Git Undo


Git-undo lets you select a region and revert changes in that region to
the most recent Git historical version.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/git-undo")
#+END_SRC

**** Browse at Remote

This package browses target pages at GitHub/Bitbucket.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package browse-at-remote
    :ensure t
    :defer t
    :bind
    ("C-c g g" . browse-at-remote))
#+END_SRC

*** Helpful

Better help system.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package helpful
    :ensure t
    :defer t
    :bind
    (
     ("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-c C-d" . helpful-at-point)
     ("C-h C" . helpful-command)))
#+END_SRC

*** Image Editing

Blimp is a great wrapper for ImageMagick:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package blimp
    :ensure t
    :defer t
    :init
    (add-hook 'image-minor-mode-hook 'blimp-mode))
#+END_SRC

*** Ivy

Ivy is a lightweight completion framework.

Install counsel first:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package counsel
    :ensure t
    :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package counsel-projectile
    :ensure t
    :after counsel
    :init
    (counsel-projectile-mode))
#+END_SRC

Smex is an enhancement for M-x.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package smex
     :ensure t
     :after counsel)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ivy
    :ensure t
    :diminish ""
    :config
    (ivy-mode 1)

    ;; When switching buffers, offer recently accessed files that we don't
    ;; currently have open.
    (setq ivy-use-virtual-buffers t)

    (setq ivy-count-format "(%d/%d) ")

    ;; Don't require order, so 'func descr' matches 'describe-function'
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))

    ;; Don't show ./ and ../ when finding files with ivy.
    ;; To go up a directory, use backspace.
    (setq ivy-extra-directories nil)

    ;; Highlight the current selection with an arrow too.
    (setq ivy-format-function 'ivy-format-function-arrow)

    ;; Don't start the search term with ^ by default. I often have a
    ;; substring in mind.
    (setq ivy-initial-inputs-alist nil)

    ;; Allow using the input as entered. This is useful when you want to
    ;; input a value that doesn't yet exist, such as creating a new file
    ;; with C-x C-f.
    (setq ivy-use-selectable-prompt t)
    :bind
    (
     ("M-x" . counsel-M-x)
     ("C-x C-f" . counsel-find-file)
     ("<f1> f" . counsel-describe-function)
     ("<f1> v" . counsel-describe-variable)
     ("C-s" . swiper)
     ("<f7>" . counsel-imenu)
     ("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

  ;; Use ido for projectile features, primarily C-x C-g (finding
  ;; files) and C-c p p (switching projects).
  (require 'projectile)
  (setq projectile-completion-system 'ivy)
#+END_SRC

*** Natural Languages

For checking spelling and grammar, I use an external Java tool: Language-tool.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package langtool
    :ensure t
    :defer t
    :config
    (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/4.3/libexec/languagetool-commandline.jar"))
#+END_SRC

*** Org-Mode

Org-Mode configuration is handled in a separate file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'org-mode-config)
#+END_SRC

*** PDF Tools

I want a nice way to work on PDF documents graphically.

Install with `brew install pdf-tools`.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package pdf-tools
    :ensure t
    :defer t
    :config
    (custom-set-variables
     '(pdf-tools-handle-upgrades nil))
    (setq pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo")
    (pdf-tools-install))
#+END_SRC

pdf-linter will "lint" a PDF document using PDFBox Preflight app.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/pdf-linter")
  (require 'pdf-linter)
  (setq pdf-linter-jar "$HOME/PDFBox/preflight-app-2.0.12.jar")
#+END_SRC

Interleave is a minor mode to interleave notes in PDF books/papers.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package interleave
    :ensure t
    :after pdf-tools)
#+END_SRC
*** Project Management

Programs are usually organized in projects, being a Git repo a natural
way to define one. I use Projectile to work on projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package projectile
    :ensure t
    :defer t
    :config
    (projectile-global-mode)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+END_SRC

*** Pandoc

Pandoc is a tool to convert between almost every document format.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package pandoc-mode
    :ensure t
    :defer t)
#+END_SRC

*** REST

For making REST calls from Emacs, I use the convenient restclient package.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package restclient
    :ensure t
    :defer t)
#+END_SRC

*** Search

For searching things, I use deadgrep, a nice interface over
ripgrep. Very fast.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package deadgrep
    :ensure t
    :defer t
    :bind ("<f5>" . deadgrep))
#+END_SRC

*** Snippets and Abbreviations

I use yasnippet for managing text snippets.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package yasnippet
    :ensure t
    :defer t
    :diminish yas-minor-mode
    :init (yas-global-mode 1))
#+END_SRC

Manage abbreviations with abbrev-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package abbrev
    :diminish abbrev-mode)
#+END_SRC

*** Syntax checking

I use flycheck for "on the fly" syntax checking.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package flycheck
    :ensure t
    :defer t
    :init (global-flycheck-mode))
#+END_SRC

Don't check documentation by default (good thing for small throwaway scripts).

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq flycheck-checkers (--remove (eq it 'emacs-lisp-checkdoc) flycheck-checkers))
#+END_SRC

*** Treemacs

Treemacs is a tree layout file explorer for Emacs:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package treemacs
    :ensure t
    :defer t
    :init
    :config
    (progn
      (setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
            treemacs-file-event-delay           5000
            treemacs-follow-after-init          t
            treemacs-follow-recenter-distance   0.1
            treemacs-goto-tag-strategy          'refetch-index
            treemacs-indentation                2
            treemacs-indentation-string         " "
            treemacs-is-never-other-window      nil
            treemacs-no-png-images              nil
            treemacs-project-follow-cleanup     nil
            treemacs-recenter-after-file-follow nil
            treemacs-recenter-after-tag-follow  nil
            treemacs-show-hidden-files          t
            treemacs-silent-filewatch           nil
            treemacs-silent-refresh             nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-tag-follow-cleanup         t
            treemacs-tag-follow-delay           1.5
            treemacs-width                      35)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null (executable-find "python3"))))
        (`(t . t)
         (treemacs-git-mode 'extended))
        (`(t . _)
         (treemacs-git-mode 'simple))))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))
#+END_SRC

Integrate Treemacs with Projectile:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)
#+END_SRC

*** Undo

For a more intuitive undo/redo management, I use undo-tree instead of
the default undo/redo system.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package undo-tree
    :ensure t
    :defer t
    :diminish undo-tree-mode
    :init (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

*** Wordpress

For editing a Wordpress blog, use org2blog.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'org2blog-config)
#+END_SRC
*** X.509

I've created a simple major mode that toggles between showing raw and
detailed information about a X.509 certificate.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'x509-certificate-mode)
#+END_SRC

*** Xcode Projects

I've created a package for working on Xcode projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/pbxproj-mode")
  (require 'pbxproj-mode)
#+END_SRC

I've also added on-the-fly syntax checking capabilities.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/flycheck-pbxproj")
  (require 'flycheck-pbxproj)
  (flycheck-pbxproj-setup)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package bazel-mode
    :ensure t
    :defer t)
#+END_SRC
