#+STARTUP: showeverything

* Introduction

This file describes the configuration of my Emacs environment.

* Reading This Document

This file is a literate programming document written with Org-mode and
Org-babel. You can generate an Emacs Lisp (.el) file for configuring
Emacs, and a HTML (.htm) file you can display in your favorite
browser.

* Generating This Document

Here's a convenience function that generates the files mentioned in
the previous section:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (defun export-init-org ()
    "Generate init.el and init.htm from the current init.org file."
    (interactive)
    (call-interactively #'org-babel-tangle)
    (call-interactively #'org-html-export-as-html))
#+END_SRC

* Contents

** General Folder Structure

 The load path is the list of directories that Emacs searches for
 executing Elisp code (ie. by using "require").

 I store the Emacs Lisp code that I write inside the user-lisp folder.

 #+BEGIN_SRC emacs-lisp :tangle yes :comments org
   (add-to-list 'load-path "~/.emacs.d/user-lisp")
 #+END_SRC

** Package Management

I use ELPA packages, mainly from the MELPA repository:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'package)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "http://orgmode.org/elpa/")))
  (package-initialize)
#+END_SRC

Bootstrap use-package:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

Add an environment variable required by the PDF Tools package:

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setenv "PKG_CONFIG_PATH" "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig:/usr/local/lib/pkgconfig:/opt/X11/lib/pkgconfig")
#+END_SRC

** General Customizations

Some general functions that I've written.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'defuns-config)
#+END_SRC

And some general keybinding modifications.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'keybindings)
#+END_SRC

*** Mac

On a Mac, I use the Command key as Meta.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
 (setq mac-option-modifier 'none)
 (setq mac-command-modifier 'meta)
 (setq ns-function-modifier 'hyper)
#+END_SRC

GUI apps on macOS do not inherit $PATH from shell. This package solves
that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :config
    (progn
      (setq exec-path-from-shell-arguments '("-l"))
      (exec-path-from-shell-initialize)))
#+END_SRC

*** Apperance and Themes

I use a custom black theme by default, but I open the possibility to
use another for a special purpose (excellent Org-Mode support, a
presentation, etc.)

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'appearance)
#+END_SRC

*** Ediff

I like Ediff's control panel to show in a separate frame, even on
graphical environments.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

*** File Backup Management

Store Emacs backup files in their own directory, so as not to pollute
the current directory.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq auto-save-list-file-name-transforms '((".*", "~/.emacs.d/auto-save-list" t)))
#+END_SRC

*** Ido and Recentf

I use Ido ("Interactive Do") as a simple way to switch between open
buffers.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (ido-mode t)
#+END_SRC

Recentf is a mode for displaying recently open files.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (recentf-mode 1)
#+END_SRC

*** Line Numbers

I use linum mode, but only for programming modes.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

Format linum-mode output by appending a space at the end.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq linum-format "%d ")
#+END_SRC

I also highlight the current line, only for programming modes.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

*** Mode Line

Show in which function or method the point is.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (which-function-mode 1)
#+END_SRC

Show column numbers in the mode line.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (column-number-mode 1)
#+END_SRC

I don't want some minor modes polluting my mode line. I use the
diminish package to avoid that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package diminish
    :ensure t)
#+END_SRC

*** Pairs

To ease working with pairs, I use the smartparens package.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package smartparens
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package smartparens-config
    :ensure smartparens
    :config
    (progn
      (show-smartparens-global-mode t))
      (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
      (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode))
#+END_SRC

Highlight parentheses pairs.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (show-paren-mode 1)
  (set-face-background 'show-paren-match-face "#aaaaaa")
  (set-face-attribute 'show-paren-match-face nil
  :weight 'bold :underline nil :overline nil :slant
  'normal)
#+END_SRC

Close pairs automatically.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (electric-pair-mode 1)
#+END_SRC

*** Trailing Whitespace

Remove trailing whitespace before saving a file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Window Management

I use winner-mode to manage my windows with convenient undo/redo functions.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (winner-mode 1)
#+END_SRC

** Programming Language Customizations

These are my customizations for the programming languages I use most.

I generally dislike tabs in my programs.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** C/C++/Objective-C/Objective-C++

For C languages, I use K&R style, with an indentation of 2 spaces.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cc-mode
  :config
  (add-hook 'c-mode-hook (lambda ()
                           (c-set-style "k&r")
                           (setq c-basic-offset 2))))
#+END_SRC

As there's not a specific Emacs mode for this programming language,
for Objective-C++ files, use Objective-C mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'auto-mode-alist '("\\.mm$" . objc-mode))
#+END_SRC

*** Clojure

Cider is the "de facto" package for working on Clojure projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cider
    :ensure t)
#+END_SRC

*** Emacs Lisp

Suggest.el is a nice package that helps you discover Elisp functions
that do what you want.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package suggest
    :ensure t)
#+END_SRC

*** JavaScript

Use js2-mode for JavaScript.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package js2-mode
    :ensure t
    :mode ("\\.js\\'" . js2-mode))
#+END_SRC

*** LaTeX

Use Auctex with tex-site for an excellent LaTeX environment. Also,
enable RefTeX mode whenever a LaTeX document is open.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package tex-site
    :ensure auctex
    :config
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex))
#+END_SRC

*** Markdown

I use markdown-mode to work on Markdown (.md) documents.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package markdown-mode
    :ensure t
    :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode))
#+END_SRC
<
*** PHP

Emacs does not come with a mode for editing PHP mode. Just use
php-mode form the package repository.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package php-mode
    :ensure t
    :mode ("\\.php\\'" . php-mode))
#+END_SRC

*** Python

There are several packages for writing Python code. I use python.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package python
    :ensure t
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+END_SRC

*** Shell

For linting Shell scripts, I integrate Shellcheck with Flycheck.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC

*** Swift

I use swift-mode for Swift code.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package swift-mode
    :ensure t
    :mode ("\\.swift\\'" . swift-mode)
    :config
    (setq flycheck-swift-sdk-path "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk")
    (add-to-list 'flycheck-checkers 'swift))
#+END_SRC

** General Productivity Packages

This is the list of the packages I use for productivity when
programming, writing in a natural language, or managing Git, for
example.

*** Autocompletion

Autocompletion is very important for programming languages and natural
languages. I use company for that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package company
    :ensure t
    :diminish company-mode
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-backends (delete 'company-semantic company-backends)))
#+END_SRC

Syntactic autocompletion for C++ and related languages provides me
with more appropriate autocompletion options provided that I instruct
the system with the compilation flags, so that it can parse source
code files. I use YouCompleteMe (ycm) for that.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ycmd
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'ycmd-mode)
    (set-variable 'ycmd-server-command (list "python" (substitute-in-file-name "$HOME/Projects/ycmd/ycmd/__main__.py")))
    (setq ycmd-parse-conditions '(save new-line mode-enabled idle-change))
    (setq url-show-status nil))
#+END_SRC

I integrate ycm with company.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package company-ycmd
    :ensure t
    :init
    (company-ycmd-setup)
    :config
    (setq company-idle-delay 0.1)
    (add-hook 'c++-mode-hook 'company-mode))
#+END_SRC

And also with flycheck.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package flycheck-ycmd
    :ensure t
    :init
    (flycheck-ycmd-setup)
    :config
    (add-hook 'c++-mode-hook 'flycheck-mode))
#+END_SRC

*** CMake

CMake is a meta-build system that is commonly used in C++ projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package cmake-mode
    :ensure t)
#+END_SRC

*** Code Formatting

Code formatting tools make smarter decisions than typical Emacs
indenters, specially for complex languages like C++. As yet, I use
clang-format for C++ and related languages.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package clang-format
    :ensure t
    :bind
    ("C-c i" . clang-format-region)
    ("C-c u" . clang-format-buffer))
#+END_SRC

*** Code Navigation

For quick navigation inside a source file, I use ace-jump-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package ace-jump-mode
    :ensure ace-jump-mode
    :init
    (global-set-key (kbd "C-c SPC") 'ace-jump-mode))
#+END_SRC

Typically, I want to navigate quickly over the instances of a
particular symbol in a source file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package highlight-symbol
    :ensure t
    :config
    (define-key prog-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key prog-mode-map (kbd "M-p") 'highlight-symbol-prev)
    ;; Modes that inherit from c-mode aren't affected by prog-mode-map,
    ;; so we have to set bindings again.
    (define-key c-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key c-mode-map (kbd "M-p") 'highlight-symbol-prev)
    (define-key c++-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key c++-mode-map (kbd "M-p") 'highlight-symbol-prev)
    (define-key java-mode-map (kbd "M-n") 'highlight-symbol-next)
    (define-key java-mode-map (kbd "M-p") 'highlight-symbol-prev))
#+END_SRC

*** Debugging

Debugging is very important when working on a program. I use RealGud,
which is a nice abstraction over several debuggers for programming
languages.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package realgud
    :ensure t)
#+END_SRC

*** Documentation

For showing inline documentation for Emacs Lisp functions, I use eldoc.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package eldoc
    :ensure t
    :diminish eldoc-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode))
#+END_SRC

In general, I use Dash docsets for any programming language. For now,
dash-at-point only works for C++ files.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package dash-at-point
    :ensure t
    :config
    (add-to-list 'dash-at-point-mode-alist '(c++-mode . "cpp"))
    :bind
    ("C-c h" . dash-at-point))
#+END_SRC

*** Git

For working on Git repositories and associated services (currently
GitHub only) I use several packages.

**** Magit

Magit is the best Git porcelain I've ever used.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package magit
    :ensure t
    :bind
    ("C-x g" . magit-status)
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+END_SRC

**** MagitHub

MagitHub extends Magit with functions to work on GitHub repositories
(show open issues, PRs, etc.).

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package magithub
    :after magit
    :config
    (magithub-feature-autoinject t))
#+END_SRC

**** Git TimeMachine

git-timemachine is a package that intuitively shows previous versions
of a particular file from a Git repository.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package git-timemachine
    :ensure t)
#+END_SRC

**** Browse at Remote

This package browses target pages at GitHub/Bitbucket.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package browse-at-remote
    :ensure t
    :config
    (global-set-key (kbd "C-c g g ") 'browse-at-remote))
#+END_SRC

*** Helm

Helm is a great incremental completion and selection narrowing framework.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package helm
    :ensure t
    :diminish helm-mode
    :init (helm-mode)
    :config
    (setq helm-ff-auto-update-initial-value t)
    :bind
    (;; Redefine M-x to use Helm
     ("M-x" . helm-M-x)
     ;; File navigation on steroids
     ("C-x C-f" . helm-find-files)
     ;; Great kill ring cycling
     ("M-y" . helm-show-kill-ring)
     ;; Find buffers and recent files using Helm mini
     ("C-x b" . helm-mini)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-z" . helm-select-action)))
#+END_SRC

*** Natural Languages

For checking spelling and grammar, I use a external Java tool: Language-tool.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package langtool
    :ensure t
    :config
    (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/3.6/libexec/languagetool-commandline.jar"))
#+END_SRC

*** Org-Mode

Org-Mode configuration is handled in a separate file.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (require 'org-mode-config)
#+END_SRC

*** PDF Tools

I want a nice way to work on PDF documents graphically.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install))
#+END_SRC

*** Project Management

Programs are usually organized in projects, being a Git repo a natural
way to define one. I use Projectile to work on projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package projectile
    :ensure t
    :config
    (projectile-global-mode)
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))
#+END_SRC

I also integrate Projectile with Helm.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package helm-projectile
    :ensure t)
#+END_SRC

*** REST

For making REST calls from Emacs, I use the convenient restclient package.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package restclient
    :ensure t)
#+END_SRC

*** Search

I like fast searches of text and symbols inside a project. As a faster
way of grepping a project, I use Silver Searcher (ag) and integrate it
with Helm.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package helm-ag
    :ensure t
    :bind ("C-c p A" . helm-do-ag-project-root))
#+END_SRC

*** Snippets and Abbreviations

I use yasnippet for managing text snippets.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :init (yas-global-mode 1))
#+END_SRC

Manage abbreviations with abbrev-mode.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package abbrev
    :diminish abbrev-mode)
#+END_SRC

*** Syntax checking

I use flycheck for "on the fly" syntax checking.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+END_SRC

Don't check documentation by default (good thing for small throwaway scripts).

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (setq flycheck-checkers (--remove (eq it 'emacs-lisp-checkdoc) flycheck-checkers))
#+END_SRC

*** Undo

For a more intuitive undo/redo management, I use undo-tree instead of
the default undo/redo system.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :init (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

*** Xcode Projects

I've created a package for working on Xcode projects.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/pbxproj-mode")
  (require 'pbxproj-mode)
#+END_SRC

I've also added on-the-fly syntax checking capabilities.

#+BEGIN_SRC emacs-lisp :tangle yes :comments org
  (add-to-list 'load-path "~/.emacs.d/user-lisp/flycheck-pbxproj")
  (require 'flycheck-pbxproj)
  (flycheck-pbxproj-setup)
#+END_SRC
